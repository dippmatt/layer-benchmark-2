from pathlib import Path
import pandas as pd
import plotly.express as px
import matplotlib.pyplot as plt
import numpy as np

def read_layer_names(layer_names_txt):
    with open(layer_names_txt, 'r') as f:
        lines = f.readlines()
    layer_names = []
    for line in lines:
        layer_names.append(line.strip())
    return layer_names

def data_metrics(tensor_values, tensor_values_ref):
    # print(tensor_values.shape)
    # print(tensor_values_ref.shape)
    # print(tensor_values.dtype)
    # print(tensor_values_ref.dtype)
    # import sys; sys.exit()
    tensor_values = tensor_values.astype(np.float64)
    tensor_values_ref = tensor_values_ref.astype(np.float64)

    return_metrics = {}
    return_metrics['rmse'] = rmse(tensor_values_ref, tensor_values)
    return_metrics['mae'] = mae(tensor_values_ref, tensor_values)
    return_metrics['l2r'] = l2r(tensor_values_ref, tensor_values)
    # if return_metrics['l2r'] > 1.1:
    #     print("large error")
    return return_metrics


def rmse(ref, pred):
  """Return Root Mean Squared Error (RMSE)."""
  return np.sqrt(((ref - pred).astype(np.float64) ** 2).mean())

def mae(ref, pred):
  """Return Mean Absolute Error (MAE)."""
  return (np.abs(ref - pred).astype(np.float64)).mean()

def l2r(ref, pred):
  """Compute L2 relative error"""
  def magnitude(v):
    return np.sqrt(np.sum(np.square(v).flatten()))
  mag = magnitude(pred) + np.finfo(np.float32).eps
  return magnitude(ref - pred) / mag

def main():
    """Add generated data into one pandas data frame.

    The data is generated by the benchmarking script (main.py) and saved in the data_gen folder.
    The data frame include the following columns:
    - model (ad, kws, vww, ic)
    - framework (tiny_engine, st, glow)
    - dtype (int, float)
    - flash (bytes)
    - ram   (bytes)
    - timings (mean value)
    """
    timings_dir = Path('..', '..', 'data_gen')

    df = pd.DataFrame(columns=['model', 'framework', 'dtype', 'flash', 'ram', 'avg_timing', 'config_name', 'layer_names', 'rmse', 'mae', 'l2r', 'std_dev', 'std_dev_per_layer', 'per_layer_timings', 'sum_timing', 'layer_assignments'])
    
    # Sanity check: verify the naming scheme of the benchmark folders
    framework_counter = 0
    model_counter = 0
    quant_counter = 0

    #########################################################################
    ######     Loop over all benchmarks and fill pandas data frame     ######
    #########################################################################
    
    for benchmark in timings_dir.iterdir():
        # filter empty directories
        if not any(benchmark.iterdir()):
            continue

        # empty row template for df
        new_row_data = {'config_name': benchmark.stem}
        
        ##############################################
        ###### Fill model, framework, data type ######
        ##############################################

        # frameworks
        if 'tiny_engine' in benchmark.stem:
            framework_counter += 1
            new_row_data['framework'] = 'tiny_engine'
        if 'st_' in benchmark.stem:
            framework_counter += 1
            new_row_data['framework'] = 'st'
        if 'glow_' in benchmark.stem:
            framework_counter += 1
            new_row_data['framework'] = 'glow'
        if 'tflite_' in benchmark.stem:
            framework_counter += 1
            new_row_data['framework'] = 'tflite'
        # models
        if 'ad_' in benchmark.stem:
            model_counter += 1
            new_row_data['model'] = 'ad'
        if 'kws' in benchmark.stem:
            model_counter += 1
            new_row_data['model'] = 'kws'
        if 'vww' in benchmark.stem:
            model_counter += 1
            new_row_data['model'] = 'vww'
        if 'ic' in benchmark.stem:
            model_counter += 1
            new_row_data['model'] = 'ic'
        # data type schemes (int or float)
        if 'int' in benchmark.stem:
            quant_counter += 1
            new_row_data['dtype'] = 'int'
        if 'float' in benchmark.stem:
            quant_counter += 1
            if '_quant' in benchmark.stem:
                new_row_data['dtype'] = 'int'
            else:
                new_row_data['dtype'] = 'float'
        
        ###################################################
        ############### Insert layer names ################
        ###################################################

        layer_names_file = Path(benchmark, 'layer_list.txt')
        new_row_data['layer_names'] = read_layer_names(layer_names_file)

        ###################################################
        ###### Insert average timings for all layers ######
        ###################################################
        
        mean_timings = Path(benchmark, 'all_layers_timings_mean.npz')
        assert mean_timings.exists(), f'No mean timings found for {benchmark}.'
        input_data = np.load(mean_timings)

        avg_timing =input_data['arr_0']

        if avg_timing.shape == (1,):
            avg_timing = avg_timing[0]
        else:
            avg_timing = avg_timing
        new_row_data['avg_timing'] = avg_timing

        ###################################################
        #############  Insert sum of layers ###############
        ###################################################
        
        per_layer_timings = Path(benchmark, 'per_layer_timings_mean.npz')
        assert per_layer_timings.exists(), f'No mean timings found for {benchmark}.'
        input_data = np.load(per_layer_timings)

        per_layer_timings = input_data['arr_0']
        
        # the per layer timings have shape (reps, layers)
        # now create the mean and standard deviation over the first axis (reps)
        std_dev_timing = np.std(per_layer_timings, axis=0)
        mean_timing = np.mean(per_layer_timings, axis=0)

        sum = 0.0
        for layer_timing in mean_timing:
            sum += layer_timing
        new_row_data['sum_timing'] = sum
        new_row_data['per_layer_timings'] = per_layer_timings

        ###################################################
        ###### STD DEVIATION  ######
        ###################################################
        
        std_dev_file = Path(benchmark, 'all_layers_timings_std_dev.npz')
        if not std_dev_file.exists():
            std_dev = np.array([0])
        else:
            input_data = np.load(std_dev_file)
            std_dev =input_data['arr_0']
     
        if std_dev.shape == (1,):
            std_dev = std_dev[0]
        else:
            std_dev = std_dev

        #print(std_dev)
        new_row_data['std_dev'] = float(std_dev)

        ###################################################
        ###### STD DEVIATION PER LAYER ######
        ###################################################

        std_dev_file_per_layer = Path(benchmark, 'per_layer_timings_std_dev.npz')
        if not std_dev_file_per_layer.exists():
            # print(new_row_data['framework'])
            # print(std_dev_timing.shape)
            # print()
            std_dev = np.array([0])
        else:
            input_data = np.load(std_dev_file_per_layer)
            std_dev_per_layer =input_data['arr_0']
            #print(std_dev_per_layer)
     
        if std_dev_per_layer.shape == (1,):
            std_dev_per_layer = std_dev_per_layer[0]
        else:
            std_dev_per_layer = std_dev_per_layer

        #print(std_dev)
        new_row_data['std_dev_per_layer'] = std_dev_per_layer
        
        ##################################################
        ####           Insert Ram & Flash             ####
        ##################################################

        mean_timings = Path(benchmark, 'ram_flash.txt')
        assert mean_timings.exists(), 'No ram, flash found.'
        
        with open(mean_timings, 'r') as f:
            lines = f.readlines()
        
        ram = lines[0].strip().split(' ')[-1]
        flash = lines[1].strip().split(' ')[-1]
        new_row_data['ram'] = int(ram)
        new_row_data['flash'] = int(flash)

        #################################################
        ####            Calulate Errors              ####
        #################################################

        # load reference data
        ref_data = Path(benchmark, 'ref_tensor_values.npz')
        assert ref_data.exists(), 'No reference data found.'
        ref_data = np.load(ref_data)
        ref_tensor_values = ref_data['arr_0']
        # load mcu data
        mcu_data = Path(benchmark, 'mcu_tensor_values.npz')
        assert mcu_data.exists(), 'No mcu data found.'
        mcu_data = np.load(mcu_data)
        mcu_tensor_values = mcu_data['arr_0']
        # calculate metrics
        metrics = data_metrics(mcu_tensor_values, ref_tensor_values)
        new_row_data['rmse'] = metrics['rmse']
        new_row_data['mae'] = metrics['mae']
        new_row_data['l2r'] = metrics['l2r'] + 1
        # print(metrics)

        # add the new row to the df
        df.loc[len(df)] = new_row_data
    
    ############################################################
    ######     Postprocess data & Perform experiments     ######
    ############################################################
    
    ############# Process per layer data:
        # Optimisation techniques split or fuse layers
        # in this step correspond the layers to the original (tflite) model layers
        # e.g., if the original model has 10 layers, but the optimised model has 20 layers,
        # probably 1 layer was split into 2 layers, so the first 2 layers of the optimised model
        # correspond to the first layer of the original model.
        # This analysis is done manually and represented in a list of tuples, where each tuple
        # represents the layer of the original model and the tuple elements represent the generated layers of the optimised model.


    # Original AD model has 10 layers
    layer_assignment_ad_10 = np.array([(0,), (1,), (2,), (3,), (4,), (5,), (6,), (7,), (8,), (9,)])
    layer_assignment_ad_19 = [(0, 1), (2, 3), (4, 5), (6, 7), (8, 9), (10, 11), (12, 13), (14, 15), (16, 17), (18)]
    
    # Original KWS model has 13 layers
    layer_assignment_kws_11 = [(0), (1), (2), (3), (4), (5), (6), (7), (8), (8), (9), (9), (10)]
    layer_assignment_kws_12 = [(0), (1), (2), (3), (4), (5), (6), (7), (8), (9), (10), (10), (11)]
    layer_assignment_kws_13 = [(0), (1), (2), (3), (4), (5), (6), (7), (8), (9), (10), (11), (12)]
    layer_assignment_kws_16 = [(0, 1), (2), (3, 4), (5), (6, 7), (8), (9, 10), (11), (12), (13), (14), (14), (15)]
    layer_assignment_kws_21 = [(0, 1), (2, 3), (4, 5), (6, 7), (8, 9), (10, 11), (12, 13), (14, 15), (16, 17), (18), (19), (19), (20)]
    layer_assignment_kws_24 = [(0,1,2), (3,4), (5,6), (7,8), (9,10), (11,12), (13,14), (15,16), (17,18), (19,20), (21), (21), (22,23)]

    # Original IC model has 16 layers
    layer_assignment_ic_15 = [(0), (1), (2), (3), (4), (5), (6), (7), (8), (9), (10), (11), (12), (13), (13), (14)]
    layer_assignment_ic_16 = [(0), (1), (2), (3), (4), (5), (6), (7), (8), (9), (10), (11), (12), (13), (14), (15)]
    layer_assignment_ic_17 = [(0), (1), (2), (3), (5), (6, 7), (4), (8), (10), (11, 12), (9), (13), (14), (15), (15), (16)]
    layer_assignment_ic_18 = [(0), (1), (2), (3,4), (6), (7), (5), (8,9), (11), (13), (10), (13,14), (15), (16), (16), (17)]
    layer_assignment_ic_21 = [(0), (1,2), (3,4), (5), (6,7), (8,9), (10), (11), (12,13), (14,15), (16), (17), (18), (19), (19), (20)]
    layer_assignment_ic_22 = [(0,1), (2,3), (4), (5,6), (8,9), (10), (7), (11,12), (14,15), (16), (13), (17,18), (19), (20), (20), (21)]

    # Original VWW model has 31 layers
    layer_assignment_vww_31 = [(0), (1), (2), (3), (4), (5), (6), (7), (8), (9), (10), (11), (12), (13), (14), (15), (16), (17), (18), (19), (20), (21), (22), (23), (24), (25), (26), (27), (28), (29), (30)]
    layer_assignment_vww_43 = [(0), (1, 2), (3), (4, 5), (6), (7, 8), (9), (10, 11), (12), (13, 14), (15), (16, 17), (18), (19, 20), (21), (22, 23), (24), (25, 26), (27), (28, 29), (30), (31, 32), (33), (34, 35), (36), (37, 38), (39), (40), (41), (41), (42)]
    layer_assignment_vww_57 = [(0, 1), (2, 3), (4, 5), (6, 7), (8, 9), (10, 11), (12, 13), (14, 15), (16, 17), (18, 19), (20, 21), (22, 23), (24, 25), (26, 27), (28, 29), (30, 31), (32, 33), (34, 35), (36, 37), (38, 39), (40, 41), (42, 43), (44, 45), (46, 47), (48, 49), (50, 51), (52, 53), (54), (55), (55), (56)]

    # data_list = [(0, 1), (2, 3), (4, 5), (6, 7), (8, 9), (10, 11), (12, 13), (14, 15), (16, 17), (18)]
    # df2 = pd.DataFrame({'column_name': data_list})
    # print(df2)
    # import sys;sys.exit()

    for index, row in df.iterrows():
        config_name = row["config_name"]
        layer_number = row["per_layer_timings"].shape
        if row['model'] == 'ad':
            if layer_number[-1] == 10:
                #df.at[index, 'layer_assignments'] = layer_assignment_ad_10
                df.at[index, 'layer_assignments'] = layer_assignment_ad_10
        #     elif layer_number[-1] == 19:
        #         df.at[index, 'layer_assignments'] = layer_assignment_ad_19

        # if row['model'] == 'kws':
        #     if 'nosoftmax' in config_name:
        #         # ignore all models without softmax
        #         continue
        #     else:
        #         if layer_number[-1] == 11:
        #             df.at[index, 'layer_assignments'] = layer_assignment_kws_11
        #         elif layer_number[-1] == 12:
        #             df.at[index, 'layer_assignments'] = layer_assignment_kws_12
        #         elif layer_number[-1] == 13:
        #             df.at[index, 'layer_assignments'] = layer_assignment_kws_13
        #         elif layer_number[-1] == 16:
        #             df.at[index, 'layer_assignments'] = layer_assignment_kws_16
        #         elif layer_number[-1] == 21:
        #             df.at[index, 'layer_assignments'] = layer_assignment_kws_21
        #         elif layer_number[-1] == 24:
        #             df.at[index, 'layer_assignments'] = layer_assignment_kws_24

        # if row['model'] == 'ic':
        #     if 'nosoftmax' in config_name:
        #         # ignore all models without softmax
        #         continue
        #     else:
        #         if layer_number[-1] == 15:
        #             df.at[index, 'layer_assignments'] = layer_assignment_ic_15
        #         elif layer_number[-1] == 16:
        #             df.at[index, 'layer_assignments'] = layer_assignment_ic_16
        #         elif layer_number[-1] == 17:
        #             df.at[index, 'layer_assignments'] = layer_assignment_ic_17
        #         elif layer_number[-1] == 18:
        #             df.at[index, 'layer_assignments'] = layer_assignment_ic_18
        #         elif layer_number[-1] == 21:
        #             df.at[index, 'layer_assignments'] = layer_assignment_ic_21
        #         elif layer_number[-1] == 22:
        #             df.at[index, 'layer_assignments'] = layer_assignment_ic_22

        # if row['model'] == 'vww':
        #     if 'nosoftmax' in config_name:
        #         # ignore all models without softmax
        #         continue
        #     else:
        #         if layer_number[-1] == 31:
        #             df.at[index, 'layer_assignments'] = layer_assignment_vww_31
        #         elif layer_number[-1] == 43:
        #             df.at[index, 'layer_assignments'] = layer_assignment_vww_43
        #         elif layer_number[-1] == 57:
        #             df.at[index, 'layer_assignments'] = layer_assignment_vww_57
            
        
    # for index, row in df.iterrows():
    #     print(row['layer_assignments'])
        
    import sys;sys.exit()

    
    
    #################################################
    ####              Visualisation              ####
    #################################################
    # model_name = 'kws'
    #framework_name = 'tiny_engine'
    # filtered_df = df[df['framework'] != framework_name]
    #data_type = 'int'
    #filtered_df = df[df['dtype'] == data_type]
    filtered_df = df

    #filtered_df['ram_flash_product'] = filtered_df['ram'] * filtered_df['flash'] / 10E6
    #filtered_df = filtered_df.sort_values(by='ram_flash_product')
    fig = px.scatter(filtered_df, x='ram', y='sum_timing', color='framework',
                 facet_col='model', title='Timing vs Memory', size='l2r', hover_data=['config_name', 'ram', 'flash', 'dtype', 'framework', 'avg_timing', 'l2r'])
   
    fig.show()
    return 0

if __name__ == '__main__':
    main()

